// Code generated by ent, DO NOT EDIT.

package ent

import (
	"errors"
	"fmt"

	"github.com/carbonable/carbonable-portfolio-backend/ent/customertokens"
	"github.com/carbonable/carbonable-portfolio-backend/ent/predicate"
	"github.com/carbonable/carbonable-portfolio-backend/ent/project"
)

// CustomerTokensWhereInput represents a where input for filtering CustomerTokens queries.
type CustomerTokensWhereInput struct {
	Predicates []predicate.CustomerTokens  `json:"-"`
	Not        *CustomerTokensWhereInput   `json:"not,omitempty"`
	Or         []*CustomerTokensWhereInput `json:"or,omitempty"`
	And        []*CustomerTokensWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "address" field predicates.
	Address             *string  `json:"address,omitempty"`
	AddressNEQ          *string  `json:"addressNEQ,omitempty"`
	AddressIn           []string `json:"addressIn,omitempty"`
	AddressNotIn        []string `json:"addressNotIn,omitempty"`
	AddressGT           *string  `json:"addressGT,omitempty"`
	AddressGTE          *string  `json:"addressGTE,omitempty"`
	AddressLT           *string  `json:"addressLT,omitempty"`
	AddressLTE          *string  `json:"addressLTE,omitempty"`
	AddressContains     *string  `json:"addressContains,omitempty"`
	AddressHasPrefix    *string  `json:"addressHasPrefix,omitempty"`
	AddressHasSuffix    *string  `json:"addressHasSuffix,omitempty"`
	AddressEqualFold    *string  `json:"addressEqualFold,omitempty"`
	AddressContainsFold *string  `json:"addressContainsFold,omitempty"`

	// "project_address" field predicates.
	ProjectAddress             *string  `json:"projectAddress,omitempty"`
	ProjectAddressNEQ          *string  `json:"projectAddressNEQ,omitempty"`
	ProjectAddressIn           []string `json:"projectAddressIn,omitempty"`
	ProjectAddressNotIn        []string `json:"projectAddressNotIn,omitempty"`
	ProjectAddressGT           *string  `json:"projectAddressGT,omitempty"`
	ProjectAddressGTE          *string  `json:"projectAddressGTE,omitempty"`
	ProjectAddressLT           *string  `json:"projectAddressLT,omitempty"`
	ProjectAddressLTE          *string  `json:"projectAddressLTE,omitempty"`
	ProjectAddressContains     *string  `json:"projectAddressContains,omitempty"`
	ProjectAddressHasPrefix    *string  `json:"projectAddressHasPrefix,omitempty"`
	ProjectAddressHasSuffix    *string  `json:"projectAddressHasSuffix,omitempty"`
	ProjectAddressEqualFold    *string  `json:"projectAddressEqualFold,omitempty"`
	ProjectAddressContainsFold *string  `json:"projectAddressContainsFold,omitempty"`

	// "slot" field predicates.
	Slot      *int  `json:"slot,omitempty"`
	SlotNEQ   *int  `json:"slotNEQ,omitempty"`
	SlotIn    []int `json:"slotIn,omitempty"`
	SlotNotIn []int `json:"slotNotIn,omitempty"`
	SlotGT    *int  `json:"slotGT,omitempty"`
	SlotGTE   *int  `json:"slotGTE,omitempty"`
	SlotLT    *int  `json:"slotLT,omitempty"`
	SlotLTE   *int  `json:"slotLTE,omitempty"`

	// "token_id" field predicates.
	TokenID             *string  `json:"tokenID,omitempty"`
	TokenIDNEQ          *string  `json:"tokenIDNEQ,omitempty"`
	TokenIDIn           []string `json:"tokenIDIn,omitempty"`
	TokenIDNotIn        []string `json:"tokenIDNotIn,omitempty"`
	TokenIDGT           *string  `json:"tokenIDGT,omitempty"`
	TokenIDGTE          *string  `json:"tokenIDGTE,omitempty"`
	TokenIDLT           *string  `json:"tokenIDLT,omitempty"`
	TokenIDLTE          *string  `json:"tokenIDLTE,omitempty"`
	TokenIDContains     *string  `json:"tokenIDContains,omitempty"`
	TokenIDHasPrefix    *string  `json:"tokenIDHasPrefix,omitempty"`
	TokenIDHasSuffix    *string  `json:"tokenIDHasSuffix,omitempty"`
	TokenIDEqualFold    *string  `json:"tokenIDEqualFold,omitempty"`
	TokenIDContainsFold *string  `json:"tokenIDContainsFold,omitempty"`

	// "value" field predicates.
	Value             *string  `json:"value,omitempty"`
	ValueNEQ          *string  `json:"valueNEQ,omitempty"`
	ValueIn           []string `json:"valueIn,omitempty"`
	ValueNotIn        []string `json:"valueNotIn,omitempty"`
	ValueGT           *string  `json:"valueGT,omitempty"`
	ValueGTE          *string  `json:"valueGTE,omitempty"`
	ValueLT           *string  `json:"valueLT,omitempty"`
	ValueLTE          *string  `json:"valueLTE,omitempty"`
	ValueContains     *string  `json:"valueContains,omitempty"`
	ValueHasPrefix    *string  `json:"valueHasPrefix,omitempty"`
	ValueHasSuffix    *string  `json:"valueHasSuffix,omitempty"`
	ValueEqualFold    *string  `json:"valueEqualFold,omitempty"`
	ValueContainsFold *string  `json:"valueContainsFold,omitempty"`

	// "project" edge predicates.
	HasProject     *bool                `json:"hasProject,omitempty"`
	HasProjectWith []*ProjectWhereInput `json:"hasProjectWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CustomerTokensWhereInput) AddPredicates(predicates ...predicate.CustomerTokens) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CustomerTokensWhereInput filter on the CustomerTokensQuery builder.
func (i *CustomerTokensWhereInput) Filter(q *CustomerTokensQuery) (*CustomerTokensQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCustomerTokensWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCustomerTokensWhereInput is returned in case the CustomerTokensWhereInput is empty.
var ErrEmptyCustomerTokensWhereInput = errors.New("ent: empty predicate CustomerTokensWhereInput")

// P returns a predicate for filtering customertokensslice.
// An error is returned if the input is empty or invalid.
func (i *CustomerTokensWhereInput) P() (predicate.CustomerTokens, error) {
	var predicates []predicate.CustomerTokens
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, customertokens.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.CustomerTokens, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, customertokens.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.CustomerTokens, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, customertokens.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, customertokens.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, customertokens.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, customertokens.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, customertokens.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, customertokens.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, customertokens.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, customertokens.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, customertokens.IDLTE(*i.IDLTE))
	}
	if i.Address != nil {
		predicates = append(predicates, customertokens.AddressEQ(*i.Address))
	}
	if i.AddressNEQ != nil {
		predicates = append(predicates, customertokens.AddressNEQ(*i.AddressNEQ))
	}
	if len(i.AddressIn) > 0 {
		predicates = append(predicates, customertokens.AddressIn(i.AddressIn...))
	}
	if len(i.AddressNotIn) > 0 {
		predicates = append(predicates, customertokens.AddressNotIn(i.AddressNotIn...))
	}
	if i.AddressGT != nil {
		predicates = append(predicates, customertokens.AddressGT(*i.AddressGT))
	}
	if i.AddressGTE != nil {
		predicates = append(predicates, customertokens.AddressGTE(*i.AddressGTE))
	}
	if i.AddressLT != nil {
		predicates = append(predicates, customertokens.AddressLT(*i.AddressLT))
	}
	if i.AddressLTE != nil {
		predicates = append(predicates, customertokens.AddressLTE(*i.AddressLTE))
	}
	if i.AddressContains != nil {
		predicates = append(predicates, customertokens.AddressContains(*i.AddressContains))
	}
	if i.AddressHasPrefix != nil {
		predicates = append(predicates, customertokens.AddressHasPrefix(*i.AddressHasPrefix))
	}
	if i.AddressHasSuffix != nil {
		predicates = append(predicates, customertokens.AddressHasSuffix(*i.AddressHasSuffix))
	}
	if i.AddressEqualFold != nil {
		predicates = append(predicates, customertokens.AddressEqualFold(*i.AddressEqualFold))
	}
	if i.AddressContainsFold != nil {
		predicates = append(predicates, customertokens.AddressContainsFold(*i.AddressContainsFold))
	}
	if i.ProjectAddress != nil {
		predicates = append(predicates, customertokens.ProjectAddressEQ(*i.ProjectAddress))
	}
	if i.ProjectAddressNEQ != nil {
		predicates = append(predicates, customertokens.ProjectAddressNEQ(*i.ProjectAddressNEQ))
	}
	if len(i.ProjectAddressIn) > 0 {
		predicates = append(predicates, customertokens.ProjectAddressIn(i.ProjectAddressIn...))
	}
	if len(i.ProjectAddressNotIn) > 0 {
		predicates = append(predicates, customertokens.ProjectAddressNotIn(i.ProjectAddressNotIn...))
	}
	if i.ProjectAddressGT != nil {
		predicates = append(predicates, customertokens.ProjectAddressGT(*i.ProjectAddressGT))
	}
	if i.ProjectAddressGTE != nil {
		predicates = append(predicates, customertokens.ProjectAddressGTE(*i.ProjectAddressGTE))
	}
	if i.ProjectAddressLT != nil {
		predicates = append(predicates, customertokens.ProjectAddressLT(*i.ProjectAddressLT))
	}
	if i.ProjectAddressLTE != nil {
		predicates = append(predicates, customertokens.ProjectAddressLTE(*i.ProjectAddressLTE))
	}
	if i.ProjectAddressContains != nil {
		predicates = append(predicates, customertokens.ProjectAddressContains(*i.ProjectAddressContains))
	}
	if i.ProjectAddressHasPrefix != nil {
		predicates = append(predicates, customertokens.ProjectAddressHasPrefix(*i.ProjectAddressHasPrefix))
	}
	if i.ProjectAddressHasSuffix != nil {
		predicates = append(predicates, customertokens.ProjectAddressHasSuffix(*i.ProjectAddressHasSuffix))
	}
	if i.ProjectAddressEqualFold != nil {
		predicates = append(predicates, customertokens.ProjectAddressEqualFold(*i.ProjectAddressEqualFold))
	}
	if i.ProjectAddressContainsFold != nil {
		predicates = append(predicates, customertokens.ProjectAddressContainsFold(*i.ProjectAddressContainsFold))
	}
	if i.Slot != nil {
		predicates = append(predicates, customertokens.SlotEQ(*i.Slot))
	}
	if i.SlotNEQ != nil {
		predicates = append(predicates, customertokens.SlotNEQ(*i.SlotNEQ))
	}
	if len(i.SlotIn) > 0 {
		predicates = append(predicates, customertokens.SlotIn(i.SlotIn...))
	}
	if len(i.SlotNotIn) > 0 {
		predicates = append(predicates, customertokens.SlotNotIn(i.SlotNotIn...))
	}
	if i.SlotGT != nil {
		predicates = append(predicates, customertokens.SlotGT(*i.SlotGT))
	}
	if i.SlotGTE != nil {
		predicates = append(predicates, customertokens.SlotGTE(*i.SlotGTE))
	}
	if i.SlotLT != nil {
		predicates = append(predicates, customertokens.SlotLT(*i.SlotLT))
	}
	if i.SlotLTE != nil {
		predicates = append(predicates, customertokens.SlotLTE(*i.SlotLTE))
	}
	if i.TokenID != nil {
		predicates = append(predicates, customertokens.TokenIDEQ(*i.TokenID))
	}
	if i.TokenIDNEQ != nil {
		predicates = append(predicates, customertokens.TokenIDNEQ(*i.TokenIDNEQ))
	}
	if len(i.TokenIDIn) > 0 {
		predicates = append(predicates, customertokens.TokenIDIn(i.TokenIDIn...))
	}
	if len(i.TokenIDNotIn) > 0 {
		predicates = append(predicates, customertokens.TokenIDNotIn(i.TokenIDNotIn...))
	}
	if i.TokenIDGT != nil {
		predicates = append(predicates, customertokens.TokenIDGT(*i.TokenIDGT))
	}
	if i.TokenIDGTE != nil {
		predicates = append(predicates, customertokens.TokenIDGTE(*i.TokenIDGTE))
	}
	if i.TokenIDLT != nil {
		predicates = append(predicates, customertokens.TokenIDLT(*i.TokenIDLT))
	}
	if i.TokenIDLTE != nil {
		predicates = append(predicates, customertokens.TokenIDLTE(*i.TokenIDLTE))
	}
	if i.TokenIDContains != nil {
		predicates = append(predicates, customertokens.TokenIDContains(*i.TokenIDContains))
	}
	if i.TokenIDHasPrefix != nil {
		predicates = append(predicates, customertokens.TokenIDHasPrefix(*i.TokenIDHasPrefix))
	}
	if i.TokenIDHasSuffix != nil {
		predicates = append(predicates, customertokens.TokenIDHasSuffix(*i.TokenIDHasSuffix))
	}
	if i.TokenIDEqualFold != nil {
		predicates = append(predicates, customertokens.TokenIDEqualFold(*i.TokenIDEqualFold))
	}
	if i.TokenIDContainsFold != nil {
		predicates = append(predicates, customertokens.TokenIDContainsFold(*i.TokenIDContainsFold))
	}
	if i.Value != nil {
		predicates = append(predicates, customertokens.ValueEQ(*i.Value))
	}
	if i.ValueNEQ != nil {
		predicates = append(predicates, customertokens.ValueNEQ(*i.ValueNEQ))
	}
	if len(i.ValueIn) > 0 {
		predicates = append(predicates, customertokens.ValueIn(i.ValueIn...))
	}
	if len(i.ValueNotIn) > 0 {
		predicates = append(predicates, customertokens.ValueNotIn(i.ValueNotIn...))
	}
	if i.ValueGT != nil {
		predicates = append(predicates, customertokens.ValueGT(*i.ValueGT))
	}
	if i.ValueGTE != nil {
		predicates = append(predicates, customertokens.ValueGTE(*i.ValueGTE))
	}
	if i.ValueLT != nil {
		predicates = append(predicates, customertokens.ValueLT(*i.ValueLT))
	}
	if i.ValueLTE != nil {
		predicates = append(predicates, customertokens.ValueLTE(*i.ValueLTE))
	}
	if i.ValueContains != nil {
		predicates = append(predicates, customertokens.ValueContains(*i.ValueContains))
	}
	if i.ValueHasPrefix != nil {
		predicates = append(predicates, customertokens.ValueHasPrefix(*i.ValueHasPrefix))
	}
	if i.ValueHasSuffix != nil {
		predicates = append(predicates, customertokens.ValueHasSuffix(*i.ValueHasSuffix))
	}
	if i.ValueEqualFold != nil {
		predicates = append(predicates, customertokens.ValueEqualFold(*i.ValueEqualFold))
	}
	if i.ValueContainsFold != nil {
		predicates = append(predicates, customertokens.ValueContainsFold(*i.ValueContainsFold))
	}

	if i.HasProject != nil {
		p := customertokens.HasProject()
		if !*i.HasProject {
			p = customertokens.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProjectWith) > 0 {
		with := make([]predicate.Project, 0, len(i.HasProjectWith))
		for _, w := range i.HasProjectWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProjectWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, customertokens.HasProjectWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCustomerTokensWhereInput
	case 1:
		return predicates[0], nil
	default:
		return customertokens.And(predicates...), nil
	}
}

// ProjectWhereInput represents a where input for filtering Project queries.
type ProjectWhereInput struct {
	Predicates []predicate.Project  `json:"-"`
	Not        *ProjectWhereInput   `json:"not,omitempty"`
	Or         []*ProjectWhereInput `json:"or,omitempty"`
	And        []*ProjectWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "address" field predicates.
	Address             *string  `json:"address,omitempty"`
	AddressNEQ          *string  `json:"addressNEQ,omitempty"`
	AddressIn           []string `json:"addressIn,omitempty"`
	AddressNotIn        []string `json:"addressNotIn,omitempty"`
	AddressGT           *string  `json:"addressGT,omitempty"`
	AddressGTE          *string  `json:"addressGTE,omitempty"`
	AddressLT           *string  `json:"addressLT,omitempty"`
	AddressLTE          *string  `json:"addressLTE,omitempty"`
	AddressContains     *string  `json:"addressContains,omitempty"`
	AddressHasPrefix    *string  `json:"addressHasPrefix,omitempty"`
	AddressHasSuffix    *string  `json:"addressHasSuffix,omitempty"`
	AddressEqualFold    *string  `json:"addressEqualFold,omitempty"`
	AddressContainsFold *string  `json:"addressContainsFold,omitempty"`

	// "slot" field predicates.
	Slot      *int  `json:"slot,omitempty"`
	SlotNEQ   *int  `json:"slotNEQ,omitempty"`
	SlotIn    []int `json:"slotIn,omitempty"`
	SlotNotIn []int `json:"slotNotIn,omitempty"`
	SlotGT    *int  `json:"slotGT,omitempty"`
	SlotGTE   *int  `json:"slotGTE,omitempty"`
	SlotLT    *int  `json:"slotLT,omitempty"`
	SlotLTE   *int  `json:"slotLTE,omitempty"`

	// "minter_address" field predicates.
	MinterAddress             *string  `json:"minterAddress,omitempty"`
	MinterAddressNEQ          *string  `json:"minterAddressNEQ,omitempty"`
	MinterAddressIn           []string `json:"minterAddressIn,omitempty"`
	MinterAddressNotIn        []string `json:"minterAddressNotIn,omitempty"`
	MinterAddressGT           *string  `json:"minterAddressGT,omitempty"`
	MinterAddressGTE          *string  `json:"minterAddressGTE,omitempty"`
	MinterAddressLT           *string  `json:"minterAddressLT,omitempty"`
	MinterAddressLTE          *string  `json:"minterAddressLTE,omitempty"`
	MinterAddressContains     *string  `json:"minterAddressContains,omitempty"`
	MinterAddressHasPrefix    *string  `json:"minterAddressHasPrefix,omitempty"`
	MinterAddressHasSuffix    *string  `json:"minterAddressHasSuffix,omitempty"`
	MinterAddressEqualFold    *string  `json:"minterAddressEqualFold,omitempty"`
	MinterAddressContainsFold *string  `json:"minterAddressContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "image" field predicates.
	Image             *string  `json:"image,omitempty"`
	ImageNEQ          *string  `json:"imageNEQ,omitempty"`
	ImageIn           []string `json:"imageIn,omitempty"`
	ImageNotIn        []string `json:"imageNotIn,omitempty"`
	ImageGT           *string  `json:"imageGT,omitempty"`
	ImageGTE          *string  `json:"imageGTE,omitempty"`
	ImageLT           *string  `json:"imageLT,omitempty"`
	ImageLTE          *string  `json:"imageLTE,omitempty"`
	ImageContains     *string  `json:"imageContains,omitempty"`
	ImageHasPrefix    *string  `json:"imageHasPrefix,omitempty"`
	ImageHasSuffix    *string  `json:"imageHasSuffix,omitempty"`
	ImageEqualFold    *string  `json:"imageEqualFold,omitempty"`
	ImageContainsFold *string  `json:"imageContainsFold,omitempty"`

	// "yielder_address" field predicates.
	YielderAddress             *string  `json:"yielderAddress,omitempty"`
	YielderAddressNEQ          *string  `json:"yielderAddressNEQ,omitempty"`
	YielderAddressIn           []string `json:"yielderAddressIn,omitempty"`
	YielderAddressNotIn        []string `json:"yielderAddressNotIn,omitempty"`
	YielderAddressGT           *string  `json:"yielderAddressGT,omitempty"`
	YielderAddressGTE          *string  `json:"yielderAddressGTE,omitempty"`
	YielderAddressLT           *string  `json:"yielderAddressLT,omitempty"`
	YielderAddressLTE          *string  `json:"yielderAddressLTE,omitempty"`
	YielderAddressContains     *string  `json:"yielderAddressContains,omitempty"`
	YielderAddressHasPrefix    *string  `json:"yielderAddressHasPrefix,omitempty"`
	YielderAddressHasSuffix    *string  `json:"yielderAddressHasSuffix,omitempty"`
	YielderAddressIsNil        bool     `json:"yielderAddressIsNil,omitempty"`
	YielderAddressNotNil       bool     `json:"yielderAddressNotNil,omitempty"`
	YielderAddressEqualFold    *string  `json:"yielderAddressEqualFold,omitempty"`
	YielderAddressContainsFold *string  `json:"yielderAddressContainsFold,omitempty"`

	// "offseter_address" field predicates.
	OffseterAddress             *string  `json:"offseterAddress,omitempty"`
	OffseterAddressNEQ          *string  `json:"offseterAddressNEQ,omitempty"`
	OffseterAddressIn           []string `json:"offseterAddressIn,omitempty"`
	OffseterAddressNotIn        []string `json:"offseterAddressNotIn,omitempty"`
	OffseterAddressGT           *string  `json:"offseterAddressGT,omitempty"`
	OffseterAddressGTE          *string  `json:"offseterAddressGTE,omitempty"`
	OffseterAddressLT           *string  `json:"offseterAddressLT,omitempty"`
	OffseterAddressLTE          *string  `json:"offseterAddressLTE,omitempty"`
	OffseterAddressContains     *string  `json:"offseterAddressContains,omitempty"`
	OffseterAddressHasPrefix    *string  `json:"offseterAddressHasPrefix,omitempty"`
	OffseterAddressHasSuffix    *string  `json:"offseterAddressHasSuffix,omitempty"`
	OffseterAddressIsNil        bool     `json:"offseterAddressIsNil,omitempty"`
	OffseterAddressNotNil       bool     `json:"offseterAddressNotNil,omitempty"`
	OffseterAddressEqualFold    *string  `json:"offseterAddressEqualFold,omitempty"`
	OffseterAddressContainsFold *string  `json:"offseterAddressContainsFold,omitempty"`

	// "tokens" edge predicates.
	HasTokens     *bool                       `json:"hasTokens,omitempty"`
	HasTokensWith []*CustomerTokensWhereInput `json:"hasTokensWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ProjectWhereInput) AddPredicates(predicates ...predicate.Project) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ProjectWhereInput filter on the ProjectQuery builder.
func (i *ProjectWhereInput) Filter(q *ProjectQuery) (*ProjectQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyProjectWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyProjectWhereInput is returned in case the ProjectWhereInput is empty.
var ErrEmptyProjectWhereInput = errors.New("ent: empty predicate ProjectWhereInput")

// P returns a predicate for filtering projects.
// An error is returned if the input is empty or invalid.
func (i *ProjectWhereInput) P() (predicate.Project, error) {
	var predicates []predicate.Project
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, project.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Project, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, project.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Project, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, project.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, project.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, project.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, project.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, project.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, project.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, project.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, project.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, project.IDLTE(*i.IDLTE))
	}
	if i.Address != nil {
		predicates = append(predicates, project.AddressEQ(*i.Address))
	}
	if i.AddressNEQ != nil {
		predicates = append(predicates, project.AddressNEQ(*i.AddressNEQ))
	}
	if len(i.AddressIn) > 0 {
		predicates = append(predicates, project.AddressIn(i.AddressIn...))
	}
	if len(i.AddressNotIn) > 0 {
		predicates = append(predicates, project.AddressNotIn(i.AddressNotIn...))
	}
	if i.AddressGT != nil {
		predicates = append(predicates, project.AddressGT(*i.AddressGT))
	}
	if i.AddressGTE != nil {
		predicates = append(predicates, project.AddressGTE(*i.AddressGTE))
	}
	if i.AddressLT != nil {
		predicates = append(predicates, project.AddressLT(*i.AddressLT))
	}
	if i.AddressLTE != nil {
		predicates = append(predicates, project.AddressLTE(*i.AddressLTE))
	}
	if i.AddressContains != nil {
		predicates = append(predicates, project.AddressContains(*i.AddressContains))
	}
	if i.AddressHasPrefix != nil {
		predicates = append(predicates, project.AddressHasPrefix(*i.AddressHasPrefix))
	}
	if i.AddressHasSuffix != nil {
		predicates = append(predicates, project.AddressHasSuffix(*i.AddressHasSuffix))
	}
	if i.AddressEqualFold != nil {
		predicates = append(predicates, project.AddressEqualFold(*i.AddressEqualFold))
	}
	if i.AddressContainsFold != nil {
		predicates = append(predicates, project.AddressContainsFold(*i.AddressContainsFold))
	}
	if i.Slot != nil {
		predicates = append(predicates, project.SlotEQ(*i.Slot))
	}
	if i.SlotNEQ != nil {
		predicates = append(predicates, project.SlotNEQ(*i.SlotNEQ))
	}
	if len(i.SlotIn) > 0 {
		predicates = append(predicates, project.SlotIn(i.SlotIn...))
	}
	if len(i.SlotNotIn) > 0 {
		predicates = append(predicates, project.SlotNotIn(i.SlotNotIn...))
	}
	if i.SlotGT != nil {
		predicates = append(predicates, project.SlotGT(*i.SlotGT))
	}
	if i.SlotGTE != nil {
		predicates = append(predicates, project.SlotGTE(*i.SlotGTE))
	}
	if i.SlotLT != nil {
		predicates = append(predicates, project.SlotLT(*i.SlotLT))
	}
	if i.SlotLTE != nil {
		predicates = append(predicates, project.SlotLTE(*i.SlotLTE))
	}
	if i.MinterAddress != nil {
		predicates = append(predicates, project.MinterAddressEQ(*i.MinterAddress))
	}
	if i.MinterAddressNEQ != nil {
		predicates = append(predicates, project.MinterAddressNEQ(*i.MinterAddressNEQ))
	}
	if len(i.MinterAddressIn) > 0 {
		predicates = append(predicates, project.MinterAddressIn(i.MinterAddressIn...))
	}
	if len(i.MinterAddressNotIn) > 0 {
		predicates = append(predicates, project.MinterAddressNotIn(i.MinterAddressNotIn...))
	}
	if i.MinterAddressGT != nil {
		predicates = append(predicates, project.MinterAddressGT(*i.MinterAddressGT))
	}
	if i.MinterAddressGTE != nil {
		predicates = append(predicates, project.MinterAddressGTE(*i.MinterAddressGTE))
	}
	if i.MinterAddressLT != nil {
		predicates = append(predicates, project.MinterAddressLT(*i.MinterAddressLT))
	}
	if i.MinterAddressLTE != nil {
		predicates = append(predicates, project.MinterAddressLTE(*i.MinterAddressLTE))
	}
	if i.MinterAddressContains != nil {
		predicates = append(predicates, project.MinterAddressContains(*i.MinterAddressContains))
	}
	if i.MinterAddressHasPrefix != nil {
		predicates = append(predicates, project.MinterAddressHasPrefix(*i.MinterAddressHasPrefix))
	}
	if i.MinterAddressHasSuffix != nil {
		predicates = append(predicates, project.MinterAddressHasSuffix(*i.MinterAddressHasSuffix))
	}
	if i.MinterAddressEqualFold != nil {
		predicates = append(predicates, project.MinterAddressEqualFold(*i.MinterAddressEqualFold))
	}
	if i.MinterAddressContainsFold != nil {
		predicates = append(predicates, project.MinterAddressContainsFold(*i.MinterAddressContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, project.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, project.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, project.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, project.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, project.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, project.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, project.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, project.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, project.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, project.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, project.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, project.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, project.NameContainsFold(*i.NameContainsFold))
	}
	if i.Image != nil {
		predicates = append(predicates, project.ImageEQ(*i.Image))
	}
	if i.ImageNEQ != nil {
		predicates = append(predicates, project.ImageNEQ(*i.ImageNEQ))
	}
	if len(i.ImageIn) > 0 {
		predicates = append(predicates, project.ImageIn(i.ImageIn...))
	}
	if len(i.ImageNotIn) > 0 {
		predicates = append(predicates, project.ImageNotIn(i.ImageNotIn...))
	}
	if i.ImageGT != nil {
		predicates = append(predicates, project.ImageGT(*i.ImageGT))
	}
	if i.ImageGTE != nil {
		predicates = append(predicates, project.ImageGTE(*i.ImageGTE))
	}
	if i.ImageLT != nil {
		predicates = append(predicates, project.ImageLT(*i.ImageLT))
	}
	if i.ImageLTE != nil {
		predicates = append(predicates, project.ImageLTE(*i.ImageLTE))
	}
	if i.ImageContains != nil {
		predicates = append(predicates, project.ImageContains(*i.ImageContains))
	}
	if i.ImageHasPrefix != nil {
		predicates = append(predicates, project.ImageHasPrefix(*i.ImageHasPrefix))
	}
	if i.ImageHasSuffix != nil {
		predicates = append(predicates, project.ImageHasSuffix(*i.ImageHasSuffix))
	}
	if i.ImageEqualFold != nil {
		predicates = append(predicates, project.ImageEqualFold(*i.ImageEqualFold))
	}
	if i.ImageContainsFold != nil {
		predicates = append(predicates, project.ImageContainsFold(*i.ImageContainsFold))
	}
	if i.YielderAddress != nil {
		predicates = append(predicates, project.YielderAddressEQ(*i.YielderAddress))
	}
	if i.YielderAddressNEQ != nil {
		predicates = append(predicates, project.YielderAddressNEQ(*i.YielderAddressNEQ))
	}
	if len(i.YielderAddressIn) > 0 {
		predicates = append(predicates, project.YielderAddressIn(i.YielderAddressIn...))
	}
	if len(i.YielderAddressNotIn) > 0 {
		predicates = append(predicates, project.YielderAddressNotIn(i.YielderAddressNotIn...))
	}
	if i.YielderAddressGT != nil {
		predicates = append(predicates, project.YielderAddressGT(*i.YielderAddressGT))
	}
	if i.YielderAddressGTE != nil {
		predicates = append(predicates, project.YielderAddressGTE(*i.YielderAddressGTE))
	}
	if i.YielderAddressLT != nil {
		predicates = append(predicates, project.YielderAddressLT(*i.YielderAddressLT))
	}
	if i.YielderAddressLTE != nil {
		predicates = append(predicates, project.YielderAddressLTE(*i.YielderAddressLTE))
	}
	if i.YielderAddressContains != nil {
		predicates = append(predicates, project.YielderAddressContains(*i.YielderAddressContains))
	}
	if i.YielderAddressHasPrefix != nil {
		predicates = append(predicates, project.YielderAddressHasPrefix(*i.YielderAddressHasPrefix))
	}
	if i.YielderAddressHasSuffix != nil {
		predicates = append(predicates, project.YielderAddressHasSuffix(*i.YielderAddressHasSuffix))
	}
	if i.YielderAddressIsNil {
		predicates = append(predicates, project.YielderAddressIsNil())
	}
	if i.YielderAddressNotNil {
		predicates = append(predicates, project.YielderAddressNotNil())
	}
	if i.YielderAddressEqualFold != nil {
		predicates = append(predicates, project.YielderAddressEqualFold(*i.YielderAddressEqualFold))
	}
	if i.YielderAddressContainsFold != nil {
		predicates = append(predicates, project.YielderAddressContainsFold(*i.YielderAddressContainsFold))
	}
	if i.OffseterAddress != nil {
		predicates = append(predicates, project.OffseterAddressEQ(*i.OffseterAddress))
	}
	if i.OffseterAddressNEQ != nil {
		predicates = append(predicates, project.OffseterAddressNEQ(*i.OffseterAddressNEQ))
	}
	if len(i.OffseterAddressIn) > 0 {
		predicates = append(predicates, project.OffseterAddressIn(i.OffseterAddressIn...))
	}
	if len(i.OffseterAddressNotIn) > 0 {
		predicates = append(predicates, project.OffseterAddressNotIn(i.OffseterAddressNotIn...))
	}
	if i.OffseterAddressGT != nil {
		predicates = append(predicates, project.OffseterAddressGT(*i.OffseterAddressGT))
	}
	if i.OffseterAddressGTE != nil {
		predicates = append(predicates, project.OffseterAddressGTE(*i.OffseterAddressGTE))
	}
	if i.OffseterAddressLT != nil {
		predicates = append(predicates, project.OffseterAddressLT(*i.OffseterAddressLT))
	}
	if i.OffseterAddressLTE != nil {
		predicates = append(predicates, project.OffseterAddressLTE(*i.OffseterAddressLTE))
	}
	if i.OffseterAddressContains != nil {
		predicates = append(predicates, project.OffseterAddressContains(*i.OffseterAddressContains))
	}
	if i.OffseterAddressHasPrefix != nil {
		predicates = append(predicates, project.OffseterAddressHasPrefix(*i.OffseterAddressHasPrefix))
	}
	if i.OffseterAddressHasSuffix != nil {
		predicates = append(predicates, project.OffseterAddressHasSuffix(*i.OffseterAddressHasSuffix))
	}
	if i.OffseterAddressIsNil {
		predicates = append(predicates, project.OffseterAddressIsNil())
	}
	if i.OffseterAddressNotNil {
		predicates = append(predicates, project.OffseterAddressNotNil())
	}
	if i.OffseterAddressEqualFold != nil {
		predicates = append(predicates, project.OffseterAddressEqualFold(*i.OffseterAddressEqualFold))
	}
	if i.OffseterAddressContainsFold != nil {
		predicates = append(predicates, project.OffseterAddressContainsFold(*i.OffseterAddressContainsFold))
	}

	if i.HasTokens != nil {
		p := project.HasTokens()
		if !*i.HasTokens {
			p = project.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTokensWith) > 0 {
		with := make([]predicate.CustomerTokens, 0, len(i.HasTokensWith))
		for _, w := range i.HasTokensWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTokensWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, project.HasTokensWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyProjectWhereInput
	case 1:
		return predicates[0], nil
	default:
		return project.And(predicates...), nil
	}
}
