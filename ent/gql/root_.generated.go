// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package gql

import (
	"bytes"
	"context"
	"errors"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	CustomerTokensOutput() CustomerTokensOutputResolver
	Project() ProjectResolver
	Query() QueryResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	Abi struct {
		Minter  func(childComplexity int) int
		Project func(childComplexity int) int
	}

	CustomerTokens struct {
		Address        func(childComplexity int) int
		ID             func(childComplexity int) int
		Project        func(childComplexity int) int
		ProjectAddress func(childComplexity int) int
		Slot           func(childComplexity int) int
		TokenID        func(childComplexity int) int
		Value          func(childComplexity int) int
	}

	CustomerTokensOutput struct {
		Abi             func(childComplexity int) int
		Address         func(childComplexity int) int
		ID              func(childComplexity int) int
		Image           func(childComplexity int) int
		MinterAddress   func(childComplexity int) int
		Name            func(childComplexity int) int
		OffseterAddress func(childComplexity int) int
		Slot            func(childComplexity int) int
		Tokens          func(childComplexity int) int
		YielderAddress  func(childComplexity int) int
	}

	PageInfo struct {
		EndCursor       func(childComplexity int) int
		HasNextPage     func(childComplexity int) int
		HasPreviousPage func(childComplexity int) int
		StartCursor     func(childComplexity int) int
	}

	Project struct {
		Abi             func(childComplexity int) int
		Address         func(childComplexity int) int
		ID              func(childComplexity int) int
		Image           func(childComplexity int) int
		MinterAddress   func(childComplexity int) int
		Name            func(childComplexity int) int
		OffseterAddress func(childComplexity int) int
		Slot            func(childComplexity int) int
		Tokens          func(childComplexity int) int
		YielderAddress  func(childComplexity int) int
	}

	Query struct {
		CustomerTokens func(childComplexity int, address string) int
		Node           func(childComplexity int, id string) int
		Nodes          func(childComplexity int, ids []string) int
	}

	Token struct {
		TokenID func(childComplexity int) int
		Value   func(childComplexity int) int
	}
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "Abi.minter":
		if e.complexity.Abi.Minter == nil {
			break
		}

		return e.complexity.Abi.Minter(childComplexity), true

	case "Abi.project":
		if e.complexity.Abi.Project == nil {
			break
		}

		return e.complexity.Abi.Project(childComplexity), true

	case "CustomerTokens.address":
		if e.complexity.CustomerTokens.Address == nil {
			break
		}

		return e.complexity.CustomerTokens.Address(childComplexity), true

	case "CustomerTokens.id":
		if e.complexity.CustomerTokens.ID == nil {
			break
		}

		return e.complexity.CustomerTokens.ID(childComplexity), true

	case "CustomerTokens.project":
		if e.complexity.CustomerTokens.Project == nil {
			break
		}

		return e.complexity.CustomerTokens.Project(childComplexity), true

	case "CustomerTokens.projectAddress":
		if e.complexity.CustomerTokens.ProjectAddress == nil {
			break
		}

		return e.complexity.CustomerTokens.ProjectAddress(childComplexity), true

	case "CustomerTokens.slot":
		if e.complexity.CustomerTokens.Slot == nil {
			break
		}

		return e.complexity.CustomerTokens.Slot(childComplexity), true

	case "CustomerTokens.tokenID":
		if e.complexity.CustomerTokens.TokenID == nil {
			break
		}

		return e.complexity.CustomerTokens.TokenID(childComplexity), true

	case "CustomerTokens.value":
		if e.complexity.CustomerTokens.Value == nil {
			break
		}

		return e.complexity.CustomerTokens.Value(childComplexity), true

	case "CustomerTokensOutput.abi":
		if e.complexity.CustomerTokensOutput.Abi == nil {
			break
		}

		return e.complexity.CustomerTokensOutput.Abi(childComplexity), true

	case "CustomerTokensOutput.address":
		if e.complexity.CustomerTokensOutput.Address == nil {
			break
		}

		return e.complexity.CustomerTokensOutput.Address(childComplexity), true

	case "CustomerTokensOutput.id":
		if e.complexity.CustomerTokensOutput.ID == nil {
			break
		}

		return e.complexity.CustomerTokensOutput.ID(childComplexity), true

	case "CustomerTokensOutput.image":
		if e.complexity.CustomerTokensOutput.Image == nil {
			break
		}

		return e.complexity.CustomerTokensOutput.Image(childComplexity), true

	case "CustomerTokensOutput.minter_address":
		if e.complexity.CustomerTokensOutput.MinterAddress == nil {
			break
		}

		return e.complexity.CustomerTokensOutput.MinterAddress(childComplexity), true

	case "CustomerTokensOutput.name":
		if e.complexity.CustomerTokensOutput.Name == nil {
			break
		}

		return e.complexity.CustomerTokensOutput.Name(childComplexity), true

	case "CustomerTokensOutput.offseter_address":
		if e.complexity.CustomerTokensOutput.OffseterAddress == nil {
			break
		}

		return e.complexity.CustomerTokensOutput.OffseterAddress(childComplexity), true

	case "CustomerTokensOutput.slot":
		if e.complexity.CustomerTokensOutput.Slot == nil {
			break
		}

		return e.complexity.CustomerTokensOutput.Slot(childComplexity), true

	case "CustomerTokensOutput.tokens":
		if e.complexity.CustomerTokensOutput.Tokens == nil {
			break
		}

		return e.complexity.CustomerTokensOutput.Tokens(childComplexity), true

	case "CustomerTokensOutput.yielder_address":
		if e.complexity.CustomerTokensOutput.YielderAddress == nil {
			break
		}

		return e.complexity.CustomerTokensOutput.YielderAddress(childComplexity), true

	case "PageInfo.endCursor":
		if e.complexity.PageInfo.EndCursor == nil {
			break
		}

		return e.complexity.PageInfo.EndCursor(childComplexity), true

	case "PageInfo.hasNextPage":
		if e.complexity.PageInfo.HasNextPage == nil {
			break
		}

		return e.complexity.PageInfo.HasNextPage(childComplexity), true

	case "PageInfo.hasPreviousPage":
		if e.complexity.PageInfo.HasPreviousPage == nil {
			break
		}

		return e.complexity.PageInfo.HasPreviousPage(childComplexity), true

	case "PageInfo.startCursor":
		if e.complexity.PageInfo.StartCursor == nil {
			break
		}

		return e.complexity.PageInfo.StartCursor(childComplexity), true

	case "Project.abi":
		if e.complexity.Project.Abi == nil {
			break
		}

		return e.complexity.Project.Abi(childComplexity), true

	case "Project.address":
		if e.complexity.Project.Address == nil {
			break
		}

		return e.complexity.Project.Address(childComplexity), true

	case "Project.id":
		if e.complexity.Project.ID == nil {
			break
		}

		return e.complexity.Project.ID(childComplexity), true

	case "Project.image":
		if e.complexity.Project.Image == nil {
			break
		}

		return e.complexity.Project.Image(childComplexity), true

	case "Project.minterAddress":
		if e.complexity.Project.MinterAddress == nil {
			break
		}

		return e.complexity.Project.MinterAddress(childComplexity), true

	case "Project.name":
		if e.complexity.Project.Name == nil {
			break
		}

		return e.complexity.Project.Name(childComplexity), true

	case "Project.offseterAddress":
		if e.complexity.Project.OffseterAddress == nil {
			break
		}

		return e.complexity.Project.OffseterAddress(childComplexity), true

	case "Project.slot":
		if e.complexity.Project.Slot == nil {
			break
		}

		return e.complexity.Project.Slot(childComplexity), true

	case "Project.tokens":
		if e.complexity.Project.Tokens == nil {
			break
		}

		return e.complexity.Project.Tokens(childComplexity), true

	case "Project.yielderAddress":
		if e.complexity.Project.YielderAddress == nil {
			break
		}

		return e.complexity.Project.YielderAddress(childComplexity), true

	case "Query.customerTokens":
		if e.complexity.Query.CustomerTokens == nil {
			break
		}

		args, err := ec.field_Query_customerTokens_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CustomerTokens(childComplexity, args["address"].(string)), true

	case "Query.node":
		if e.complexity.Query.Node == nil {
			break
		}

		args, err := ec.field_Query_node_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Node(childComplexity, args["id"].(string)), true

	case "Query.nodes":
		if e.complexity.Query.Nodes == nil {
			break
		}

		args, err := ec.field_Query_nodes_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Nodes(childComplexity, args["ids"].([]string)), true

	case "Token.token_id":
		if e.complexity.Token.TokenID == nil {
			break
		}

		return e.complexity.Token.TokenID(childComplexity), true

	case "Token.value":
		if e.complexity.Token.Value == nil {
			break
		}

		return e.complexity.Token.Value(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap()
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, rc.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../customertokens.graphql", Input: `type Token {
  token_id: ID!
  value: String
}

type CustomerTokensOutput {
  id: ID!
  name: String!
  slot: Int!
  address: String!
  minter_address: String!
  yielder_address: String
  offseter_address: String
  abi: Abi!
  image: String!
  tokens: [Token]
}

extend type Query {
  """
  The list of tokens per project for an address
  """
  customerTokens(address: String!): [CustomerTokensOutput!]
}
`, BuiltIn: false},
	{Name: "../project.graphql", Input: `type Abi {
  project: String
  minter: String
}
`, BuiltIn: false},
	{Name: "../ent.graphql", Input: `directive @goField(forceResolver: Boolean, name: String, omittable: Boolean) on FIELD_DEFINITION | INPUT_FIELD_DEFINITION
directive @goModel(model: String, models: [String!], forceGenerate: Boolean) on OBJECT | INPUT_OBJECT | SCALAR | ENUM | INTERFACE | UNION
"""
Define a Relay Cursor type:
https://relay.dev/graphql/connections.htm#sec-Cursor
"""
scalar Cursor
type CustomerTokens implements Node {
  id: ID!
  address: String!
  projectAddress: String!
  slot: Int!
  tokenID: String!
  value: String!
  project: [Project!]
}
"""
An object with an ID.
Follows the [Relay Global Object Identification Specification](https://relay.dev/graphql/objectidentification.htm)
"""
interface Node @goModel(model: "github.com/carbonable/carbonable-portfolio-backend/ent.Noder") {
  """
  The id of the object.
  """
  id: ID!
}
"""
Possible directions in which to order a list of items when provided an ` + "`" + `orderBy` + "`" + ` argument.
"""
enum OrderDirection {
  """
  Specifies an ascending order for a given ` + "`" + `orderBy` + "`" + ` argument.
  """
  ASC
  """
  Specifies a descending order for a given ` + "`" + `orderBy` + "`" + ` argument.
  """
  DESC
}
"""
Information about pagination in a connection.
https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo
"""
type PageInfo {
  """
  When paginating forwards, are there more items?
  """
  hasNextPage: Boolean!
  """
  When paginating backwards, are there more items?
  """
  hasPreviousPage: Boolean!
  """
  When paginating backwards, the cursor to continue.
  """
  startCursor: Cursor
  """
  When paginating forwards, the cursor to continue.
  """
  endCursor: Cursor
}
type Project implements Node {
  id: ID!
  address: String!
  slot: Int!
  minterAddress: String!
  name: String!
  abi: Abi!
  image: String!
  yielderAddress: String
  offseterAddress: String
  tokens: [CustomerTokens!]
}
type Query {
  """
  Fetches an object given its ID.
  """
  node(
    """
    ID of the object.
    """
    id: ID!
  ): Node
  """
  Lookup nodes by a list of IDs.
  """
  nodes(
    """
    The list of node IDs.
    """
    ids: [ID!]!
  ): [Node]!
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
