// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package gql

import (
	"bytes"
	"context"
	"errors"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Project() ProjectResolver
	Query() QueryResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	CustomerTokens struct {
		Address        func(childComplexity int) int
		ID             func(childComplexity int) int
		Project        func(childComplexity int) int
		ProjectAddress func(childComplexity int) int
		Slot           func(childComplexity int) int
		TokenID        func(childComplexity int) int
		Value          func(childComplexity int) int
	}

	CustomerTokensOutput struct {
		Abi             func(childComplexity int) int
		Address         func(childComplexity int) int
		ID              func(childComplexity int) int
		Image           func(childComplexity int) int
		MinterAddress   func(childComplexity int) int
		Name            func(childComplexity int) int
		OffseterAddress func(childComplexity int) int
		Slot            func(childComplexity int) int
		Tokens          func(childComplexity int) int
		YielderAddress  func(childComplexity int) int
	}

	PageInfo struct {
		EndCursor       func(childComplexity int) int
		HasNextPage     func(childComplexity int) int
		HasPreviousPage func(childComplexity int) int
		StartCursor     func(childComplexity int) int
	}

	Project struct {
		Abi             func(childComplexity int) int
		Address         func(childComplexity int) int
		ID              func(childComplexity int) int
		Image           func(childComplexity int) int
		MinterAddress   func(childComplexity int) int
		Name            func(childComplexity int) int
		OffseterAddress func(childComplexity int) int
		Slot            func(childComplexity int) int
		Tokens          func(childComplexity int) int
		YielderAddress  func(childComplexity int) int
	}

	Query struct {
		CustomerTokens func(childComplexity int, address string) int
		Node           func(childComplexity int, id string) int
		Nodes          func(childComplexity int, ids []string) int
	}

	Token struct {
		TokenID func(childComplexity int) int
		Value   func(childComplexity int) int
	}
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "CustomerTokens.address":
		if e.complexity.CustomerTokens.Address == nil {
			break
		}

		return e.complexity.CustomerTokens.Address(childComplexity), true

	case "CustomerTokens.id":
		if e.complexity.CustomerTokens.ID == nil {
			break
		}

		return e.complexity.CustomerTokens.ID(childComplexity), true

	case "CustomerTokens.project":
		if e.complexity.CustomerTokens.Project == nil {
			break
		}

		return e.complexity.CustomerTokens.Project(childComplexity), true

	case "CustomerTokens.projectAddress":
		if e.complexity.CustomerTokens.ProjectAddress == nil {
			break
		}

		return e.complexity.CustomerTokens.ProjectAddress(childComplexity), true

	case "CustomerTokens.slot":
		if e.complexity.CustomerTokens.Slot == nil {
			break
		}

		return e.complexity.CustomerTokens.Slot(childComplexity), true

	case "CustomerTokens.tokenID":
		if e.complexity.CustomerTokens.TokenID == nil {
			break
		}

		return e.complexity.CustomerTokens.TokenID(childComplexity), true

	case "CustomerTokens.value":
		if e.complexity.CustomerTokens.Value == nil {
			break
		}

		return e.complexity.CustomerTokens.Value(childComplexity), true

	case "CustomerTokensOutput.abi":
		if e.complexity.CustomerTokensOutput.Abi == nil {
			break
		}

		return e.complexity.CustomerTokensOutput.Abi(childComplexity), true

	case "CustomerTokensOutput.address":
		if e.complexity.CustomerTokensOutput.Address == nil {
			break
		}

		return e.complexity.CustomerTokensOutput.Address(childComplexity), true

	case "CustomerTokensOutput.id":
		if e.complexity.CustomerTokensOutput.ID == nil {
			break
		}

		return e.complexity.CustomerTokensOutput.ID(childComplexity), true

	case "CustomerTokensOutput.image":
		if e.complexity.CustomerTokensOutput.Image == nil {
			break
		}

		return e.complexity.CustomerTokensOutput.Image(childComplexity), true

	case "CustomerTokensOutput.minter_address":
		if e.complexity.CustomerTokensOutput.MinterAddress == nil {
			break
		}

		return e.complexity.CustomerTokensOutput.MinterAddress(childComplexity), true

	case "CustomerTokensOutput.name":
		if e.complexity.CustomerTokensOutput.Name == nil {
			break
		}

		return e.complexity.CustomerTokensOutput.Name(childComplexity), true

	case "CustomerTokensOutput.offseter_address":
		if e.complexity.CustomerTokensOutput.OffseterAddress == nil {
			break
		}

		return e.complexity.CustomerTokensOutput.OffseterAddress(childComplexity), true

	case "CustomerTokensOutput.slot":
		if e.complexity.CustomerTokensOutput.Slot == nil {
			break
		}

		return e.complexity.CustomerTokensOutput.Slot(childComplexity), true

	case "CustomerTokensOutput.tokens":
		if e.complexity.CustomerTokensOutput.Tokens == nil {
			break
		}

		return e.complexity.CustomerTokensOutput.Tokens(childComplexity), true

	case "CustomerTokensOutput.yielder_address":
		if e.complexity.CustomerTokensOutput.YielderAddress == nil {
			break
		}

		return e.complexity.CustomerTokensOutput.YielderAddress(childComplexity), true

	case "PageInfo.endCursor":
		if e.complexity.PageInfo.EndCursor == nil {
			break
		}

		return e.complexity.PageInfo.EndCursor(childComplexity), true

	case "PageInfo.hasNextPage":
		if e.complexity.PageInfo.HasNextPage == nil {
			break
		}

		return e.complexity.PageInfo.HasNextPage(childComplexity), true

	case "PageInfo.hasPreviousPage":
		if e.complexity.PageInfo.HasPreviousPage == nil {
			break
		}

		return e.complexity.PageInfo.HasPreviousPage(childComplexity), true

	case "PageInfo.startCursor":
		if e.complexity.PageInfo.StartCursor == nil {
			break
		}

		return e.complexity.PageInfo.StartCursor(childComplexity), true

	case "Project.abi":
		if e.complexity.Project.Abi == nil {
			break
		}

		return e.complexity.Project.Abi(childComplexity), true

	case "Project.address":
		if e.complexity.Project.Address == nil {
			break
		}

		return e.complexity.Project.Address(childComplexity), true

	case "Project.id":
		if e.complexity.Project.ID == nil {
			break
		}

		return e.complexity.Project.ID(childComplexity), true

	case "Project.image":
		if e.complexity.Project.Image == nil {
			break
		}

		return e.complexity.Project.Image(childComplexity), true

	case "Project.minterAddress":
		if e.complexity.Project.MinterAddress == nil {
			break
		}

		return e.complexity.Project.MinterAddress(childComplexity), true

	case "Project.name":
		if e.complexity.Project.Name == nil {
			break
		}

		return e.complexity.Project.Name(childComplexity), true

	case "Project.offseterAddress":
		if e.complexity.Project.OffseterAddress == nil {
			break
		}

		return e.complexity.Project.OffseterAddress(childComplexity), true

	case "Project.slot":
		if e.complexity.Project.Slot == nil {
			break
		}

		return e.complexity.Project.Slot(childComplexity), true

	case "Project.tokens":
		if e.complexity.Project.Tokens == nil {
			break
		}

		return e.complexity.Project.Tokens(childComplexity), true

	case "Project.yielderAddress":
		if e.complexity.Project.YielderAddress == nil {
			break
		}

		return e.complexity.Project.YielderAddress(childComplexity), true

	case "Query.customerTokens":
		if e.complexity.Query.CustomerTokens == nil {
			break
		}

		args, err := ec.field_Query_customerTokens_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CustomerTokens(childComplexity, args["address"].(string)), true

	case "Query.node":
		if e.complexity.Query.Node == nil {
			break
		}

		args, err := ec.field_Query_node_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Node(childComplexity, args["id"].(string)), true

	case "Query.nodes":
		if e.complexity.Query.Nodes == nil {
			break
		}

		args, err := ec.field_Query_nodes_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Nodes(childComplexity, args["ids"].([]string)), true

	case "Token.token_id":
		if e.complexity.Token.TokenID == nil {
			break
		}

		return e.complexity.Token.TokenID(childComplexity), true

	case "Token.value":
		if e.complexity.Token.Value == nil {
			break
		}

		return e.complexity.Token.Value(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputCustomerTokensWhereInput,
		ec.unmarshalInputProjectWhereInput,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, rc.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../customertokens.graphql", Input: `type Token {
  token_id: ID!
  value: String
}

type CustomerTokensOutput {
  id: ID!
  name: String!
  slot: Int!
  address: String!
  minter_address: String!
  yielder_address: String
  offseter_address: String
  abi: String!
  image: String!
  tokens: [Token]
}

extend type Query {
  """
  The list of tokens per project for an address
  """
  customerTokens(address: String!): [CustomerTokensOutput!]
}
`, BuiltIn: false},
	{Name: "../ent.graphql", Input: `directive @goField(forceResolver: Boolean, name: String, omittable: Boolean) on FIELD_DEFINITION | INPUT_FIELD_DEFINITION
directive @goModel(model: String, models: [String!], forceGenerate: Boolean) on OBJECT | INPUT_OBJECT | SCALAR | ENUM | INTERFACE | UNION
"""
Define a Relay Cursor type:
https://relay.dev/graphql/connections.htm#sec-Cursor
"""
scalar Cursor
type CustomerTokens implements Node {
  id: ID!
  address: String!
  projectAddress: String!
  slot: Int!
  tokenID: String!
  value: String!
  project: [Project!]
}
"""
CustomerTokensWhereInput is used for filtering CustomerTokens objects.
Input was generated by ent.
"""
input CustomerTokensWhereInput {
  not: CustomerTokensWhereInput
  and: [CustomerTokensWhereInput!]
  or: [CustomerTokensWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """
  address field predicates
  """
  address: String
  addressNEQ: String
  addressIn: [String!]
  addressNotIn: [String!]
  addressGT: String
  addressGTE: String
  addressLT: String
  addressLTE: String
  addressContains: String
  addressHasPrefix: String
  addressHasSuffix: String
  addressEqualFold: String
  addressContainsFold: String
  """
  project_address field predicates
  """
  projectAddress: String
  projectAddressNEQ: String
  projectAddressIn: [String!]
  projectAddressNotIn: [String!]
  projectAddressGT: String
  projectAddressGTE: String
  projectAddressLT: String
  projectAddressLTE: String
  projectAddressContains: String
  projectAddressHasPrefix: String
  projectAddressHasSuffix: String
  projectAddressEqualFold: String
  projectAddressContainsFold: String
  """
  slot field predicates
  """
  slot: Int
  slotNEQ: Int
  slotIn: [Int!]
  slotNotIn: [Int!]
  slotGT: Int
  slotGTE: Int
  slotLT: Int
  slotLTE: Int
  """
  token_id field predicates
  """
  tokenID: String
  tokenIDNEQ: String
  tokenIDIn: [String!]
  tokenIDNotIn: [String!]
  tokenIDGT: String
  tokenIDGTE: String
  tokenIDLT: String
  tokenIDLTE: String
  tokenIDContains: String
  tokenIDHasPrefix: String
  tokenIDHasSuffix: String
  tokenIDEqualFold: String
  tokenIDContainsFold: String
  """
  value field predicates
  """
  value: String
  valueNEQ: String
  valueIn: [String!]
  valueNotIn: [String!]
  valueGT: String
  valueGTE: String
  valueLT: String
  valueLTE: String
  valueContains: String
  valueHasPrefix: String
  valueHasSuffix: String
  valueEqualFold: String
  valueContainsFold: String
  """
  project edge predicates
  """
  hasProject: Boolean
  hasProjectWith: [ProjectWhereInput!]
}
"""
An object with an ID.
Follows the [Relay Global Object Identification Specification](https://relay.dev/graphql/objectidentification.htm)
"""
interface Node @goModel(model: "github.com/carbonable/carbonable-portfolio-backend/ent.Noder") {
  """
  The id of the object.
  """
  id: ID!
}
"""
Possible directions in which to order a list of items when provided an ` + "`" + `orderBy` + "`" + ` argument.
"""
enum OrderDirection {
  """
  Specifies an ascending order for a given ` + "`" + `orderBy` + "`" + ` argument.
  """
  ASC
  """
  Specifies a descending order for a given ` + "`" + `orderBy` + "`" + ` argument.
  """
  DESC
}
"""
Information about pagination in a connection.
https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo
"""
type PageInfo {
  """
  When paginating forwards, are there more items?
  """
  hasNextPage: Boolean!
  """
  When paginating backwards, are there more items?
  """
  hasPreviousPage: Boolean!
  """
  When paginating backwards, the cursor to continue.
  """
  startCursor: Cursor
  """
  When paginating forwards, the cursor to continue.
  """
  endCursor: Cursor
}
type Project implements Node {
  id: ID!
  address: String!
  slot: Int!
  minterAddress: String!
  name: String!
  abi: String!
  image: String!
  yielderAddress: String
  offseterAddress: String
  tokens: [CustomerTokens!]
}
"""
ProjectWhereInput is used for filtering Project objects.
Input was generated by ent.
"""
input ProjectWhereInput {
  not: ProjectWhereInput
  and: [ProjectWhereInput!]
  or: [ProjectWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """
  address field predicates
  """
  address: String
  addressNEQ: String
  addressIn: [String!]
  addressNotIn: [String!]
  addressGT: String
  addressGTE: String
  addressLT: String
  addressLTE: String
  addressContains: String
  addressHasPrefix: String
  addressHasSuffix: String
  addressEqualFold: String
  addressContainsFold: String
  """
  slot field predicates
  """
  slot: Int
  slotNEQ: Int
  slotIn: [Int!]
  slotNotIn: [Int!]
  slotGT: Int
  slotGTE: Int
  slotLT: Int
  slotLTE: Int
  """
  minter_address field predicates
  """
  minterAddress: String
  minterAddressNEQ: String
  minterAddressIn: [String!]
  minterAddressNotIn: [String!]
  minterAddressGT: String
  minterAddressGTE: String
  minterAddressLT: String
  minterAddressLTE: String
  minterAddressContains: String
  minterAddressHasPrefix: String
  minterAddressHasSuffix: String
  minterAddressEqualFold: String
  minterAddressContainsFold: String
  """
  name field predicates
  """
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """
  image field predicates
  """
  image: String
  imageNEQ: String
  imageIn: [String!]
  imageNotIn: [String!]
  imageGT: String
  imageGTE: String
  imageLT: String
  imageLTE: String
  imageContains: String
  imageHasPrefix: String
  imageHasSuffix: String
  imageEqualFold: String
  imageContainsFold: String
  """
  yielder_address field predicates
  """
  yielderAddress: String
  yielderAddressNEQ: String
  yielderAddressIn: [String!]
  yielderAddressNotIn: [String!]
  yielderAddressGT: String
  yielderAddressGTE: String
  yielderAddressLT: String
  yielderAddressLTE: String
  yielderAddressContains: String
  yielderAddressHasPrefix: String
  yielderAddressHasSuffix: String
  yielderAddressIsNil: Boolean
  yielderAddressNotNil: Boolean
  yielderAddressEqualFold: String
  yielderAddressContainsFold: String
  """
  offseter_address field predicates
  """
  offseterAddress: String
  offseterAddressNEQ: String
  offseterAddressIn: [String!]
  offseterAddressNotIn: [String!]
  offseterAddressGT: String
  offseterAddressGTE: String
  offseterAddressLT: String
  offseterAddressLTE: String
  offseterAddressContains: String
  offseterAddressHasPrefix: String
  offseterAddressHasSuffix: String
  offseterAddressIsNil: Boolean
  offseterAddressNotNil: Boolean
  offseterAddressEqualFold: String
  offseterAddressContainsFold: String
  """
  tokens edge predicates
  """
  hasTokens: Boolean
  hasTokensWith: [CustomerTokensWhereInput!]
}
type Query {
  """
  Fetches an object given its ID.
  """
  node(
    """
    ID of the object.
    """
    id: ID!
  ): Node
  """
  Lookup nodes by a list of IDs.
  """
  nodes(
    """
    The list of node IDs.
    """
    ids: [ID!]!
  ): [Node]!
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
