package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.47

import (
	"context"
	"fmt"

	"github.com/NethermindEth/starknet.go/utils"
	"github.com/carbonable/carbonable-portfolio-backend/ent/customertokens"
	"github.com/carbonable/carbonable-portfolio-backend/ent/gql"
	"github.com/carbonable/carbonable-portfolio-backend/ent/schema"
)

// Abi is the resolver for the abi field.
func (r *customerTokensOutputResolver) Abi(ctx context.Context, obj *schema.CustomerTokensDTO) (*gql.Abi, error) {
	panic(fmt.Errorf("not implemented: Abi - abi"))
}

// CustomerTokens is the resolver for the customerTokens field.
func (r *queryResolver) CustomerTokens(ctx context.Context, address string) ([]*schema.CustomerTokensDTO, error) {
	addressFelt, err := utils.HexToFelt(address)
	if err != nil {
		return nil, err
	}
	projects, err := r.Client.Project.Query().All(ctx)
	customerTokens, err := r.Client.CustomerTokens.Query().Where(customertokens.AddressEQ(addressFelt.String())).All(ctx)

	var ctds []*schema.CustomerTokensDTO
	for _, p := range projects {
		tokens := []schema.Token{}
		for _, ct := range customerTokens {
			if p.Address == ct.ProjectAddress && p.Slot == ct.Slot {
				tokens = append(tokens, schema.Token{
					TokenID: ct.TokenID,
					Value:   ct.Value,
				})
			}
		}

		ctd := &schema.CustomerTokensDTO{
			Name:            p.Name,
			Address:         p.Address,
			MinterAddress:   p.MinterAddress,
			YielderAddress:  p.YielderAddress,
			OffseterAddress: p.OffseterAddress,
			Tokens:          tokens,
			Slot:            p.Slot,
			Abi:             p.Abi,
			Image:           p.Image,
		}
		ctds = append(ctds, ctd)
	}

	return ctds, nil
}

// CustomerTokensOutput returns gql.CustomerTokensOutputResolver implementation.
func (r *Resolver) CustomerTokensOutput() gql.CustomerTokensOutputResolver {
	return &customerTokensOutputResolver{r}
}

type customerTokensOutputResolver struct{ *Resolver }
